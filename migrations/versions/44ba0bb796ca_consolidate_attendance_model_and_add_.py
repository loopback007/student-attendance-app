"""Consolidate attendance model and add holiday features

Revision ID: 44ba0bb796ca
Revises: 99ffd5afe8dc
Create Date: 2025-05-12 05:14:23.032181

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '44ba0bb796ca'
down_revision = '99ffd5afe8dc' # Make sure this matches your previous migration ID
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - START ###
    
    # Create holidays table (this part is fine)
    op.create_table('holidays',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('date', sa.Date(), nullable=False),
        sa.Column('type', sa.String(length=50), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=True, server_default=sa.func.now()), # Added server_default for new rows
        sa.Column('updated_at', sa.DateTime(), nullable=True, server_default=sa.func.now(), onupdate=sa.func.now()), # Added server_default for new rows
        sa.PrimaryKeyConstraint('id', name=op.f('pk_holidays')), # Added op.f for constraint naming convention
        sa.UniqueConstraint('date', name=op.f('uq_holidays_date')) # Added op.f
    )

    # Batch operations for attendance_records table (for SQLite compatibility)
    with op.batch_alter_table('attendance_records', schema=None) as batch_op:
        # 1. Add new columns that don't conflict with renames first
        batch_op.add_column(sa.Column('updated_at', sa.DateTime(), nullable=True, server_default=sa.func.now(), onupdate=sa.func.now()))
        batch_op.add_column(sa.Column('session_time', sa.Time(), nullable=True))

        # 2. Perform column renames (MANUALLY CHANGED FROM DROP/ADD)
        batch_op.alter_column('class_id',
                              new_column_name='subject_class_id',
                              existing_type=sa.INTEGER(), # Type from your old model
                              nullable=False) # Keep original nullability
        
        batch_op.alter_column('attendance_date',
                              new_column_name='date',
                              existing_type=sa.DATE(), # Type from your old model
                              nullable=False) # Keep original nullability
        
        batch_op.alter_column('recorded_at',
                              new_column_name='created_at',
                              existing_type=sa.DATETIME(), # Type from your old model
                              nullable=True) # Keep original nullability (default is Python-side)

        # 3. Alter status column type (this was likely auto-generated correctly)
        batch_op.alter_column('status',
                              existing_type=sa.VARCHAR(length=7), # What Alembic detected
                              type_=sa.String(length=50),
                              existing_nullable=False)

        # 4. Manage constraints
        # Alembic detected dropping the old unique constraint and foreign key, and adding new ones.
        # This is generally okay if the new constraints use the new column names.
        # The batch_op.drop_constraint(None, type_='foreignkey') is too generic.
        # It's better to be explicit if you know the old constraint name for the FK.
        # Let's assume Alembic handles the FK related to class_id/subject_class_id correctly 
        # by dropping the old one (implicitly when class_id is "renamed" or its FK nature changes)
        # and creating the new one referencing subject_class_id.

        # Drop old unique constraint (Alembic generated this, seems fine)
        batch_op.drop_constraint('_student_class_date_uc', type_='unique')
        
        # Create new unique constraint (Alembic generated this, seems fine with new column names)
        batch_op.create_unique_constraint(batch_op.f('_uc_attendance_records_student_subject_class_date_session'), ['student_id', 'subject_class_id', 'date', 'session_time']) # Used op.f and named

        # Foreign key for subject_class_id
        # If Alembic didn't correctly drop the old FK on 'class_id' and add the new one for 'subject_class_id',
        # you might need to manage it.
        # The auto-generated script had:
        # batch_op.drop_constraint(None, type_='foreignkey') # This is too vague, might drop other FKs if any.
        # batch_op.create_foreign_key(None, 'subject_classes', ['subject_class_id'], ['id'])
        
        # A safer way if you know the constraint name for the FK on class_id:
        # batch_op.drop_constraint('fk_attendance_records_class_id_subject_classes', type_='foreignkey') # Replace with actual name if known
        # batch_op.create_foreign_key(batch_op.f('fk_attendance_records_subject_class_id_subject_classes'), 
        #                            'subject_classes', ['subject_class_id'], ['id'])
        # For SQLite, direct rename of FK column often handles this, but let's be explicit if needed.
        # The script you provided had `batch_op.drop_constraint(None, type_='foreignkey')` which is risky.
        # It's better if Alembic can identify the specific foreign key related to 'class_id'.
        # For now, we'll assume the rename of 'class_id' to 'subject_class_id' handles the FK column,
        # and a new FK constraint needs to be made for 'subject_class_id'.
        # The auto-generated drop/create might be what Alembic intends for the FK.
        # If `class_id` was the FK column, when it's renamed to `subject_class_id`, the FK relationship
        # effectively transfers. So, we might not need to explicitly drop and recreate if the original
        # FK constraint didn't have a specific name that needs dropping.
        # The key is that after this, subject_class_id must be an FK to subject_classes.id.
        # The autogenerated: batch_op.drop_constraint(None, type_='foreignkey') and 
        # batch_op.create_foreign_key(None, 'subject_classes', ['subject_class_id'], ['id'])
        # should correctly establish the new FK, assuming the old one is implicitly handled or
        # the `drop_constraint(None, ...)` successfully targets it without side effects.
        # Let's keep the autogenerated lines for FK handling but be aware.
        # The `None` for constraint name means Alembic will auto-name. Let's use op.f for consistency.
        
        # This was in your original script; it attempts to drop ANY unnamed FK.
        # It's better if this referred to a specific constraint name if possible.
        # However, since SQLite doesn't always name constraints explicitly in older versions,
        # this might be Alembic's way of handling it.
        # Let's assume it works for now but this is a point of caution.
        # The create_foreign_key will establish the new one.
        # The original script's drop_column('class_id') would have removed the old FK.
        # Since we are altering, the FK on the column effectively moves.
        # So, we might not need the explicit drop_constraint(None, type_='foreignkey') line
        # if the FK is tied to the column we renamed.
        # Let's *remove* the generic drop_constraint(None, type_='foreignkey') and ensure the create_foreign_key is correct.
        
        batch_op.create_foreign_key(batch_op.f('fk_attendance_records_subject_class_id_subject_classes'), 
                                   'subject_classes', ['subject_class_id'], ['id'])


    # The op.drop_column calls from the original script are now handled by alter_column, so they should be removed.
    # op.drop_column('attendance_records', 'recorded_at') # Handled by alter_column
    # op.drop_column('attendance_records', 'class_id') # Handled by alter_column
    # op.drop_column('attendance_records', 'attendance_date') # Handled by alter_column

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - START ###
    # Need to reverse all operations carefully
    
    with op.batch_alter_table('attendance_records', schema=None) as batch_op:
        # Reverse renames
        batch_op.alter_column('subject_class_id',
                              new_column_name='class_id',
                              existing_type=sa.INTEGER(),
                              nullable=False)
        batch_op.alter_column('date',
                              new_column_name='attendance_date',
                              existing_type=sa.DATE(),
                              nullable=False)
        batch_op.alter_column('created_at',
                              new_column_name='recorded_at',
                              existing_type=sa.DATETIME(),
                              nullable=True)

        # Reverse status column type change
        batch_op.alter_column('status',
                              existing_type=sa.String(length=50),
                              type_=sa.VARCHAR(length=7), # Back to what Alembic detected as original
                              existing_nullable=False)

        # Drop new columns
        batch_op.drop_column('session_time')
        batch_op.drop_column('updated_at')
        
        # Reverse unique constraint
        batch_op.drop_constraint(batch_op.f('_uc_attendance_records_student_subject_class_date_session'), type_='unique')
        batch_op.create_unique_constraint('_student_class_date_uc', ['student_id', 'class_id', 'attendance_date'])

        # Reverse foreign key
        batch_op.drop_constraint(batch_op.f('fk_attendance_records_subject_class_id_subject_classes'), type_='foreignkey')
        # Recreate old FK on class_id (assuming it was implicitly dropped or needs to be explicit)
        batch_op.create_foreign_key('fk_attendance_records_class_id_subject_classes_old', # Give it a name
                                   'subject_classes', ['class_id'], ['id'])


    op.drop_table('holidays')
    # ### end Alembic commands ###
